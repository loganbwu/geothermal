head(trace1)
df = data.frame(x=c(1,3,2,54,3))
df %>% mutate(i = 1:length(df$x))
library(magrittr)
df %>% mutate(i = 1:length(df$x))
library(dplyr)
df %>% mutate(i = 1:length(df$x))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning=FALSE)
library(rjags)
library(coda)
library(readxl)
library(igraph)
library(plotly)
library(tidyverse)
library(extrafont)
library(gridExtra)
library(lemon)
library(xtable)
library(openssl)
library(knitr)
library(kableExtra)
knit_print.data.frame <- lemon_print
configpath = '../wairakei_data/config.xlsx'
regdatapath = '../wairakei_data/data.xlsx'
extraliqregpath = "../wairakei_data/extra_liq.csv" # for regression
extradatapath = "../wairakei_data/well_pi.csv"     # ts data
pipath <- "../wairakei_data/short version Generation Projection 2016.xlsx"
base_year = '2000'
prediction_date = '2017-12-01'
production_curve_wells = c('wk255', 'wk263')
tsplotwells = c("wk118", "wk216", "wk605")
decline_wells = c(production_curve_wells, "wk272", "wk86", "wk116")
base_datetime = as.POSIXct(paste(base_year, 1, 1, sep='-'))
today_datetime = as.POSIXct(prediction_date)
# theme_update(text=element_text(family="Times New Roman"))
'%ni%' <- Negate('%in%')
# for over-plotting
special_wells = c(production_curve_wells, tsplotwells, "wk86", "wk116")
use.censor = F
n_steps = 1000
censor = function(x, type) {
# Hash the facility identifier (beware of hash clashes)
if (!use.censor) {
return(x)
} else if (type=="well") {
return(paste0("w", toupper(substr(sha1(x), 1, 3))))
} else if (type=="fp") {
return(paste0("fp", toupper(substr(sha1(x), 1, 2))))
}
}
# read in config data
configsheets = excel_sheets(configpath)
for (sheet in configsheets) {
assign(sheet, read_excel(configpath, sheet))
}
stopifnot(!anyDuplicated(well_fp_map$well)) # each well cannot map to multiple flash plants
# read in PI data
PI <- read_excel(pipath, "From PI sheet", skip=1) %>%
rename(facility = Unit,
variable = X__1,
id = X__2,
description = X__3,
code = X__4) %>%
gather(key="datechar", value="value", -c(facility, variable, id, description, code)) %>%
mutate(date = as.Date(as.numeric(datechar), origin = "1899-12-30"),
value = as.numeric(value)) %>% select(-c(datechar, id)) %>%
mutate_if(is.character, tolower) %>%
mutate(value = as.numeric(value)) %>%
drop_na(value) %>%
filter(date >= as.Date("2017-11-01"), date < as.Date(prediction_date)) %>%
filter(!str_detect(variable, "condition|calc")) %>%
filter(str_detect(facility, "wk"))
extra_liq <- PI %>%
select(facility, date, variable, value) %>%
# filter(value>1e-4) %>%
filter(str_detect(variable, "plot|phase|whp|flow")) %>%
spread(key=variable, value=value) %>%
mutate(mf = pmax(`2phase flow`, `fp14  plot flow`, `fp15  plot flow`, `flow`, na.rm=T),
whp = pmax(`fp14  plot whp`, `fp15  plot whp`, `fp16  plot whp`, `whp`, na.rm=T),
source = "PI Database") %>%
select(well=facility, date, whp, mf, source) %>%
drop_na()
# read in regression data (plus extra)
regression_df = read_excel(regdatapath) %>% mutate(source="Well Tests")
dry_df = PI %>%
filter(str_detect(facility, "wk")) %>%
select(facility, date, variable, value) %>%
# filter(value>1e-2) %>%
group_by(facility, date) %>%
spread(key=variable, value=value) %>%
select(facility, date, `ip sf`, `actual massflow`) %>%
gather(key="key", value="mf", `ip sf`, `actual massflow`) %>%
ungroup() %>%
drop_na() %>%
rename(well=facility)
dry_df$well = censor(dry_df$well, "well")
extra_liq$well = censor(extra_liq$well, "well")
fp_constants$fp = censor(fp_constants$fp, "fp")
fp_gen_map$fp = censor(fp_gen_map$fp, "fp")
operating_conditions$well = censor(operating_conditions$well, "well")
regression_df$well = censor(regression_df$well, "well")
well_fp_map$well = censor(well_fp_map$well, "well")
well_fp_map$fp = censor(well_fp_map$fp, "fp")
production_curve_wells = censor(production_curve_wells, "well")
special_wells = censor(special_wells, "well")
tsplotwells = censor(tsplotwells, "well")
# combine with extra
regression_df = plyr::rbind.fill(regression_df, extra_liq)
regression_df = regression_df %>%
mutate(date_numeric = as.numeric(date - base_datetime)) %>%
mutate(date_numeric=ifelse(date_numeric>0, date_numeric, NA))  # remove dates before baseline
dry_df = dry_df %>%
filter(well %ni% unique(regression_df$well)) %>%
mutate(date_numeric = as.numeric(as.POSIXct(date) - base_datetime)) %>%
mutate(date_numeric=ifelse(date_numeric>0, date_numeric, NA))  # remove dates before baseline
well_fp_map = well_fp_map %>% select(well, fp) %>% drop_na()
# today_numeric = (Sys.time() - base_datetime) %>% as.numeric()
today_numeric = (today_datetime - base_datetime) %>% as.numeric()
# assign unique facility IDs
liq_wells = unique(regression_df$well) # aka production curve wells
dry_wells = unique(dry_df$well)        # aka time series wells
map_wells = unique(well_fp_map$well)   # any well mapped in config
well_names = unique(c(liq_wells, dry_wells))
fp_names = c(well_fp_map$fp, fp_gen_map$fp, fp_constants$fp) %>% unique()
fluid_types = c('ip', 'lp', 'w')
gen_names = gen_constants$gen %>% unique() %>% sort()
ip_gen_names = paste(gen_names, 'ip', sep='_')
lp_gen_names = paste(gen_names, 'lp', sep='_')
w_gen_names = paste(gen_names, 'w', sep='_')
dummy_gen_names = c(ip_gen_names, lp_gen_names, w_gen_names) %>% sort()
all_names = c('DUMMY', well_names, fp_names, dummy_gen_names, gen_names)
ids = 1:length(all_names)
names(ids) = all_names
# check data quality
no_data_wells = map_wells[!map_wells %in% c(liq_wells, dry_wells)]  # see which ones we're completely guessing for
no_map_wells = c(liq_wells, dry_wells)[!c(liq_wells, dry_wells) %in% map_wells]
missing = data.frame(Wells = c(paste(no_map_wells, collapse=", ")),
row.names = c("Data available but no FP"))
print(xtable(missing, type = "latex",
caption=paste0("Potential data quality issues. ", names(ids)[71], " is known to be not connected, and ", names(ids)[31], " has an A/B pairing with ", names(ids)[32], "."),
label="tab:quality"),
file = "../_media/quality.tex")
# add names in data with IDs
regression_df = regression_df %>% mutate(well_id=ids[well])
dry_df = dry_df %>% mutate(well_id=ids[well])
operating_conditions = operating_conditions %>% mutate(well_id=ids[well]) %>% rename(whp_pred=whp)
fp_constants = fp_constants %>% mutate(fp_id=ids[fp])
gen_constants = gen_constants %>% mutate(gen_id=ids[gen]) %>% select(-gen)
well_fp_map = well_fp_map %>% mutate(well_id=ids[well], fp_id=ids[fp]) %>% select(-c(well, fp))
fp_gen_map = fp_gen_map %>% mutate(fp_id=ids[fp], gen_ip_id=ids[gen_ip], gen_lp_id=ids[gen_lp], gen_w_id=ids[gen_w]) %>% select(-c(fp, gen_ip, gen_lp, gen_w))
incomplete.fps = unique(well_fp_map %>%
filter(is.na(well_id)) %>%
mutate(fp = names(ids)[fp_id]) %>%
pull(fp))
# create connectivity matrix. i flows to j
# wells to FPs
v = matrix(0, nrow=length(ids), ncol=length(ids))
v[1,-1] = 1
for (i in 1:nrow(well_fp_map)) {
id_i = well_fp_map[[i, 1]]
id_j = well_fp_map[[i, 2]]
v[id_i, id_j] = 1
}
# send ip/lp/w flows to dummy gens
for (i in 1:nrow(fp_gen_map)) {
id_i = fp_gen_map[[i, 1]]
for (j in 2:ncol(fp_gen_map)) {
facility_j = names(ids)[fp_gen_map[[i, j]]]
facility_dummy_j = paste(facility_j, fluid_types[j-1], sep='_')
id_j = ids[facility_dummy_j]
if (!is.na(id_j)) {
v[id_i, id_j] = 1
}
}
}
# dummy gens to gens
for (i in 1:nrow(gen_constants)) {
id_j = gen_constants$gen_id[i]
facility_j = names(ids)[id_j]
for (fluid in fluid_types) {
facility_dummy_i = paste(facility_j, fluid, sep='_')
id_i = ids[facility_dummy_i]
v[id_i, id_j] = 1
}
}
# convert form
m = matrix(0, nrow=nrow(v), ncol=max(colSums(v)))
rownames(m) = all_names
for (i in 1:nrow(v)) {
for (j in 1:ncol(v)) {
if (v[[i, j]]==1) {
m[j, sum(m[j,]>0)+1] = i
}
}
}
flows_to = function(well) {
return(names(ids)[m[well,]][-1])
}
# generate coordinates
dummy_locs = data.frame(name='DUMMY', x=-0.1, y=0)
well_locs = data.frame(name=well_names, x=0, y=seq(1, 1/(length(well_names)-1), length.out=length(well_names)))
fp_locs = data.frame(name=fp_names, x=1, y=seq(0, 1, length.out=length(fp_names)))
gen_dummy_locs = data.frame(name=dummy_gen_names, x=2, y=seq(0, 1, length.out=length(dummy_gen_names)))
gen_locs = data.frame(name=gen_names, x=2.5, y=seq(1/11, 10/11, length.out=length(gen_names)))
locs = rbind(dummy_locs, well_locs, fp_locs, gen_dummy_locs, gen_locs)
locs$id = ids[locs$name]
locs = locs %>% arrange(id)
g = graph_from_adjacency_matrix(v) %>%
set_vertex_attr('label', value=all_names) %>%
set_vertex_attr('x', value=as.vector(locs$x)) %>%
set_vertex_attr('y', value=as.vector(locs$y)) %>%
set_vertex_attr('label.degree', value=pi) %>%
as.undirected()
V(g)$size = ifelse(V(g)$label %in% well_names, 4, 8)
V(g)$color = ifelse(V(g)$label %in% dry_wells, "red", ifelse(V(g)$label %in% no_data_wells, "grey", "orange"))
E(g)$color = "black"
E(g)[which(tail_of(g, E(g))$label=="DUMMY")]$color = "grey"
# png("../_media/full_network.png")
# par(mar=c(0,3,0,0), family="Times")
# plot(g, vertex.label.dist=3,
#      mark.groups = list(wells=ids[well_names], fps=ids[fp_names], gens=ids[gen_names]),
#      mark.col = "#DDDDDD",
#      mark.border = NA)
# text(c(-1, -0.3, 0.4, 0.9), 1.15, c("Wells", "Flash plants", "Dummy gens", "Generators"), cex=1.25)
# dev.off()
plot(g, vertex.label.dist=3,
mark.groups = list(wells=ids[well_names], fps=ids[fp_names], gens=ids[gen_names]),
mark.col = "#DDDDDD",
mark.border = NA)
regression_list = regression_df %>% select(well_id, whp, mf, date_numeric) %>% as.list()
dry_list = dry_df %>%
filter(date < prediction_date) %>%
rename(well_id_dry=well_id, mf_dry=mf, date_numeric_dry=date_numeric) %>% # use these in a different regression
select(well_id_dry, mf_dry, date_numeric_dry) %>% as.list()
operating_conditions_list = operating_conditions %>% arrange(well_id) %>% select(whp_pred) %>% as.list()
fp_constants_list = as.list(fp_constants)
gen_constants_list = as.list(gen_constants %>% select(gen_id, factor))
facilities = data.frame(id=ids) %>%
left_join(operating_conditions %>% rename(id=well_id) %>% filter(id %in% ids) %>% select(-well), by='id') %>%
left_join(gen_constants %>% select(factor, id=gen_id), by='id') %>%
left_join(fp_constants %>% rename(id=fp_id), by='id') %>%
filter(id %in% ids) %>%  # in case extras specified in data
mutate(mf_pred=NA) %>%
mutate(n_inflows=colSums(v))
well_ids = ids[well_names]
liq_well_ids = ids[liq_wells]
dry_well_ids = ids[dry_wells]
fp_ids = ids[fp_names]
ip_gen_ids = ids[ip_gen_names]
lp_gen_ids = ids[lp_gen_names]
w_gen_ids = ids[w_gen_names]
gen_ids = ids[gen_names]
# force all mass to IP steam
dry_fps = c("poi dry", "direct ip")
dry_fp_ids = ids[dry_fps]
facilities$hf_ip[facilities$id %in% dry_fp_ids] = 10
facilities$hfg_ip[facilities$id %in% dry_fp_ids] = 10
facilities_list = facilities %>% select(-id) %>% as.list()
# experimental TS data matrix for dry wells
ar_order = 1
empty = setNames(data.frame(matrix(ncol = length(all_names), nrow = 0)), all_names)
drymatrix = dry_df %>%
select(well, date_numeric, mf) %>%
spread(well, mf) %>%
select(-date_numeric)
drymatrix = empty %>%
full_join(drymatrix) %>%
as.matrix()
ar_well_ids = which(complete.cases(t(drymatrix[1:(ar_order+1),])))
ar_wells = names(ids)[ar_well_ids]
# which wells can we not use AR for
dry_no_ar_wells = dry_wells[!dry_well_ids %in% ar_well_ids]
dry_no_ar_well_ids = ids[dry_no_ar_wells]
# insert production curve predictions
stopifnot(all(tsplotwells %in% dry_df$well))
tsplotwells = ar_wells
days_since_last = as.integer(today_datetime - as.POSIXct(max(dry_df$date)))
prod = expand.grid(whp_prod=seq(6, 16, length.out=10),
well_id_prod=ids[production_curve_wells])
ts = expand.grid(date_numeric_ts=seq(min(dry_df$date_numeric), max(dry_df$date_numeric)+days_since_last, length.out=10),
well_id_ts=ids[tsplotwells])
prod_list = prod %>% as.list
ts_list = ts %>% as.list
# extend matrix for prediction
drymatrix = rbind(drymatrix, matrix(NA, nrow=days_since_last, ncol=ncol(drymatrix)))
# combine into one list
data = c(regression_list, dry_list, facilities_list, prod_list, ts_list,
list(well_ids=well_ids, liq_well_ids=liq_well_ids,
dry_well_ids=dry_well_ids, dry_no_ar_well_ids=dry_no_ar_well_ids,
fp_ids=fp_ids,
gen_ids=gen_ids, ip_gen_ids=ip_gen_ids, lp_gen_ids=lp_gen_ids, w_gen_ids=w_gen_ids,
today_numeric=today_numeric, m=m, dummy=1,
ts=drymatrix, ts_ar=drymatrix, ts_ema=drymatrix, ar_well_ids=ar_well_ids))
# data$whp_pred[is.na(data$whp_pred)] <- mean(data$whp_pred, na.rm=T)
# center covariates
mean_whp <- mean(data$whp, na.rm=T)
mean_date_numeric <- mean(data$date_numeric, na.rm=T)
data$whp_c <- data$whp - mean_whp
data$whp_pred_c <- data$whp_pred - mean_whp
data$whp_prod_c <- data$whp_prod - mean_whp
data$date_numeric_c <- data$date_numeric - mean_date_numeric
data$today_numeric_c <- data$today_numeric - mean_date_numeric
data$date_numeric_dry_c <- data$date_numeric_dry - mean_date_numeric
data$date_numeric_ts <- data$date_numeric_ts - mean_date_numeric
pidataplot = ggplot(regression_df %>% filter(source=="PI Database"), aes(x=whp, y=mf, color=well)) +
geom_point() +
labs(title=paste("PI Regression Data from", min(extra_liq$date), "to", max(extra_liq$date)),
x="Well-head pressure (bar)",
y="Mixed-phase mass flow (T/h)",
color="Well") +
guides(color=guide_legend(ncol=2)) +
ggsave('../_media/pi_data.png', width=24.7, height=12, units='cm')
ggplotly(pidataplot)
code = "
data {
D <- dim(ts)
}
model {
##############################################
# fit individual regressions to liquid wells #
##############################################
for (i in 1:length(mf)) {
mu[i] <- Intercept[well_id[i]] + beta_whp[well_id[i]] * whp_c[i] + beta_date[well_id[i]] * date_numeric_c[i]
mf[i] ~ dnorm(mu[i], tau[well_id[i]])
mf_fit[i] ~ dnorm(mu[i], tau[well_id[i]])
# mf_fit[i] ~ dnorm(mu[i]*measurement_error_factor[i], tau[well_id[i]])
# measurement_error_factor[i] ~ dunif(0.9, 1.1)
}
# fit regression to dry wells
for (i in 1:length(mf_dry)) {
mu_dry[i] <- Intercept[well_id_dry[i]] + beta_date[well_id_dry[i]] * date_numeric_dry_c[i]
mf_dry[i] ~ dnorm(mu_dry[i], tau[well_id_dry[i]])
mf_dry_fit[i] ~ dnorm(mu_dry[i], tau[well_id_dry[i]])
# measurement_error_factor_dry[i] ~ dunif(0.9, 1.1)
}
for (j in dry_well_ids) {
Intercept[j] ~ dnorm(0, 1e-12)
beta_date[j] ~ dnorm(0, 1e-12)
tau[j] ~ dgamma(1e-12, 1e-12)
}
# experimental AR1 model for dry wells
for (j in ar_well_ids) {
for (t in 2:D[1]) {
mu_ar[t,j] <- c_ar[j] + theta_ar[j]*ts_ar[t-1,j]
ts_ar[t,j] ~ dnorm(mu_ar[t,j], tau_ar[j]) T(0,)
}
theta_ar[j] ~ dnorm(0, 1e-12)
c_ar[j] ~ dnorm(0, 1e-12)
tau_ar[j] ~ dgamma(1e-12, 1e-12)
}
# experimental EWMA model (use at your own risk)
for (j in ar_well_ids) {
for (t in 2:D[1]) {
mu_ema[t,j] <- alpha*mu_ema[t-1,j] + (1-alpha)*ts_ema[t,j]
ts_ema[t,j] ~ dnorm(mu_ema[t-1,j], tau_ema[j]) T(0,)
}
mu_ema[1,j] <- ts_ema[1,j]
theta_ema[j] ~ dnorm(0, 1e-12)
c_ema[j] ~ dnorm(0, 1e-12)
tau_ema[j] ~ dgamma(1e-12, 1e-12)
}
alpha ~ dbeta(0.5, 0.5)
# HIERARCHICAL
# fills in for any missing wells
for (j in liq_well_ids) {
Intercept[j] ~ dnorm(mu_Intercept, tau_Intercept)
beta_whp[j] ~ dnorm(mu_beta_whp, tau_beta_whp)
# beta_whp2[j] ~ dnorm(mu_beta_whp2, tau_beta_whp2)
beta_date[j] ~ dnorm(mu_beta_date, tau_beta_date)
tau[j] ~ dgamma(1e-12, 1e-12)
sd[j] <- 1/max(sqrt(tau[j]), 1e-12)
}
# fill in any missing data
for (i in 1:length(mf)) {
date_numeric_c[i] ~ dnorm(mu_date_numeric, tau_date_numeric)
}
mu_date_numeric ~ dnorm(0, 1e-12)
tau_date_numeric ~ dnorm(1e-12, 1e-12)
# set hyperparameters
mu_Intercept ~ dnorm(0, 1e-12)
mu_beta_whp ~ dnorm(0, 1e-12)
# mu_beta_whp2 ~ dnorm(0, 1e-12)
mu_beta_date ~ dnorm(0, 1e-12)
tau_Intercept ~ dgamma(1e-12, 1e-12)
tau_beta_whp ~ dgamma(1e-12, 1e-12)
# tau_beta_whp2 ~ dgamma(1e-12, 1e-12)
tau_beta_date ~ dgamma(1e-12, 1e-12)
#####################################
# production curve for verification #
#####################################
for (i in 1:length(whp_prod)) {
mu_prod[i] <- Intercept[well_id_prod[i]] + beta_whp[well_id_prod[i]] * whp_prod_c[i] + beta_date[well_id_prod[i]] * today_numeric_c
# mf_prod[i] ~ dnorm(mu_prod[i], tau[well_id_prod[i]])
mf_prod[i] <- mu_prod[i]
}
for (i in 1:length(date_numeric_ts)) {
mu_ts[i] <- Intercept[well_id_ts[i]] + beta_date[well_id_ts[i]] * date_numeric_ts[i]
mf_ts[i] ~ dnorm(mu_ts[i], tau[well_id_ts[i]])
}
#########################################################
# simple model to fill in missing FP enthalpy constants #
#########################################################
for (i in fp_ids) {
# missing fp constants
hf_ip[i] ~ dgamma(param[1], param[7])
hg_ip[i] ~ dgamma(param[2], param[8])
hfg_ip[i] ~ dgamma(param[3], param[9])
hf_lp[i] ~ dgamma(param[4], param[10])
hg_lp[i] ~ dgamma(param[5], param[11])
hfg_lp[i] ~ dgamma(param[6], param[12])
}
for (i in c(1, well_ids)) {
h[i] ~ dgamma(param[13], param[14])
whp_pred_c[i] ~ dnorm(param[15], param[16])
} # missing well constants
for (i in 1:16) { param[i] ~ dgamma(1e-12, 1e-12) }               # uniform priors
########################################
# make predictions (the stuff we want) #
########################################
mf_pred[dummy] <- 0  # dummy well
ip_sf[dummy] <- 0
lp_sf[dummy] <- 0
wf[dummy] <- 0
# use production curve
for (j in liq_well_ids) {
mf_pred[j] <- max(Intercept[j] + beta_whp[j] * whp_pred_c[j] + beta_date[j] * today_numeric_c, 0)
}
# use naive TS reg
for (j in dry_well_ids) { #dry_no_ar_well_ids) {
mf_pred[j] <- max(Intercept[j] + beta_date[j] * today_numeric_c, 0)
}
# use AR(1)
# for (j in ar_well_ids) {
#   mf_pred[j] <- mu_ar[D[1], j]
# }
for (i in fp_ids) {
mf_pred[i] <- sum(mf_pred[m[i,1:n_inflows[i]]])
h[i] <- sum(mf_pred[m[i, 1:n_inflows[i]]] * h[m[i, 1:n_inflows[i]]]) / ifelse(mf_pred[i]!=0, mf_pred[i], 1)
ip_sf[i] <- min(max((h[i] - hf_ip[i]), 0) / hfg_ip[i], 1) * mf_pred[i]
lp_sf[i] <- min(max((min(hf_ip[i], h[i]) - hf_lp[i]), 0) / hfg_lp[i], 1) * (mf_pred[i] - ip_sf[i])
total_sf[i] <- ip_sf[i] + lp_sf[i]
wf[i] <- mf_pred[i] - total_sf[i]
}
# dummy gens and actual gens
for (i in ip_gen_ids) { mf_pred[i] <- sum(ip_sf[m[i, 1:n_inflows[i]]]) }
for (i in lp_gen_ids) { mf_pred[i] <- sum(lp_sf[m[i, 1:n_inflows[i]]]) }
for (i in w_gen_ids) { mf_pred[i] <- sum(wf[m[i, 1:n_inflows[i]]]) }
for (i in gen_ids) {
mf_pred[i] <- sum(mf_pred[m[i,1:n_inflows[i]]])
power[i] <- mf_pred[i] / mu_factor[i]
mu_factor[i] ~ dunif(0.95*factor[i], 1.05*factor[i])  # uncertainty from email
}
total_power <- sum(power[gen_ids])
}
"
# cat(code, file="model.txt")
vars =  c('mf_fit',
'mf_dry_fit',
'mf_ts',
'mf_prod',
'mf_pred',
'beta_date',
'sd',
'power',
'total_sf',
'mu_ar',
'ts_ar',
'mu_ema',
'ts_ema',
'alpha',
'ip_sf',
'lp_sf',
'wf',
paste0('h[', fp_ids, ']'),
paste0('mu_', c('Intercept', 'beta_whp', 'beta_date')),
'total_power')
n_chains = 2
burn_in = 100
model = jags.model(textConnection(code), data, n.chains=n_chains)
update(model, burn_in)
out = coda.samples(model, n.iter=round(n_steps/n_chains), variable.names=vars)
outmatrix = as.matrix(out)
outframe = as.data.frame(outmatrix) %>%
gather(key=facility, value=value) %>%
mutate(variable=gsub("\\[.*$", "", facility), facility=parse_number(facility, na=c("NA")))
outframe$facility = factor(names(ids)[outframe$facility])
trace1 <- outframe %>%
filter(variable=='mf_pred', facility==censor('wk256', "well")) %>%
mutate(index = 1:nrow(trace1))
df
df %>% mutate(i = 1:nrow(.))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning=FALSE)
library(reticulate)
use_python("/Users/loganwu/miniconda3/bin/python")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning=FALSE)
library(reticulate)
use_python("/Users/loganwu/miniconda3/bin/python")
use_python("/Users/loganwu/miniconda3/bin/python")
use_python("/Users/loganwu/miniconda3/bin/python", required=T)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning=FALSE)
library(reticulate)
# use_python("/Users/loganwu/miniconda3/bin/python", required=T)
use_condaenv("base", required=T)
# use_python("/Users/loganwu/miniconda3/bin/python", required=T)
use_condaenv("engsci761", required=T)
sys = import("sys")
sys
sys$version
use_python("/Users/loganwu/miniconda3/bin/python", required=T)
sys$version
use_python('/usr/local/bin/python3')
sys$version
